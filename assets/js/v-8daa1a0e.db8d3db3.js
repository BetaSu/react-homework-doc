"use strict";(self.webpackChunkreact53_doc=self.webpackChunkreact53_doc||[]).push([[509],{464:(e,d,c)=>{c.r(d),c.d(d,{data:()=>o});const o={key:"v-8daa1a0e",path:"/",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"这一次，真的学懂React😄",slug:"这一次-真的学懂react😄",children:[{level:3,title:"例一",slug:"例一",children:[]},{level:3,title:"例二",slug:"例二",children:[]}]},{level:2,title:"难学的源头",slug:"难学的源头",children:[]},{level:2,title:"该怎么学",slug:"该怎么学",children:[{level:3,title:"1. 主动实践",slug:"_1-主动实践",children:[]},{level:3,title:"2. 课后习题",slug:"_2-课后习题",children:[]},{level:3,title:"3. 课后讨论",slug:"_3-课后讨论",children:[]}]},{level:2,title:"我们会怎么学",slug:"我们会怎么学",children:[]},{level:2,title:"还等什么，撸起袖子一起愉快的学习吧～",slug:"还等什么-撸起袖子一起愉快的学习吧",children:[]}],filePathRelative:"index.md",git:{updatedTime:162885063e4,contributors:[]}}},590:(e,d,c)=>{c.r(d),c.d(d,{default:()=>Y});var o=c(252);const a=(0,o._)("h2",{id:"这一次-真的学懂react😄",tabindex:"-1"},[(0,o._)("a",{class:"header-anchor",href:"#这一次-真的学懂react😄","aria-hidden":"true"},"#"),(0,o.Uk)(" 这一次，真的学懂React😄")],-1),r=(0,o._)("p",null,[(0,o.Uk)("大家好，我是卡颂。"),(0,o._)("code",null,"React"),(0,o.Uk)("真是太难学了。")],-1),l=(0,o.Uk)("一开始，我以为原因是我菜。但在用了3年"),t=(0,o._)("code",null,"React",-1),n=(0,o.Uk)("、深入学习其源码并写了"),i={href:"https://react.iamkasong.com/",target:"_blank",rel:"noopener noreferrer"},h=(0,o.Uk)("React技术揭秘"),s=(0,o.Uk)("后发现，问题出在"),u=(0,o._)("code",null,"React",-1),p=(0,o.Uk)("本身。"),k=(0,o.uE)('<p>他太反直觉了。我举两个例子：</p><h3 id="例一" tabindex="-1"><a class="header-anchor" href="#例一" aria-hidden="true">#</a> 例一</h3><p>你用过<code>PureComponent</code>、<code>React.memo</code>这两个<code>API</code>么？他们的作用是？</p><p>你可能会说：这两个是性能优化<code>API</code>，用来减少不必要的<code>render</code>。</p><p>那么问题来了，为什么会有不必要的<code>render</code>？最符合直觉的更新方式莫过于：<code>A</code>组件触发更新，那么只有<code>A</code>及其子孙组件会<code>render</code>。</p><p>然而在<code>React</code>中，<code>A</code>触发更新，与<code>A</code>不相干的<code>B</code>也可能<code>render</code>，所以需要<code>PureComponent</code>这样的性能优化<code>API</code>阻止<code>B</code>的无意义<code>render</code>。</p><p>所以，为了熟练掌握<code>PureComponent</code>、<code>React.memo</code>的使用，你得先了解<code>React</code>内部的更新流程。</p><h3 id="例二" tabindex="-1"><a class="header-anchor" href="#例二" aria-hidden="true">#</a> 例二</h3><p><code>Hooks</code>是<code>React</code>的未来。这是个优秀的设计，很多库都借鉴了他的理念（比如<code>Vue3</code>的<code>Composition API</code>）。</p>',9),_=(0,o.Uk)("在"),m={href:"https://zh-hans.reactjs.org/docs/hooks-rules.html",target:"_blank",rel:"noopener noreferrer"},b=(0,o.Uk)("React文档"),g=(0,o.Uk)("提到，使用"),f=(0,o._)("code",null,"Hooks",-1),U=(0,o.Uk)("需要遵循如下限制："),R=(0,o.uE)('<blockquote><p>不要在循环，条件或嵌套函数中调用 Hook</p></blockquote><p>作为借鉴其理念的<code>Vue3 Composition API</code>就没有这样的限制，是不是很奇怪？</p><h2 id="难学的源头" tabindex="-1"><a class="header-anchor" href="#难学的源头" aria-hidden="true">#</a> 难学的源头</h2><p>以上两个例子都指出一个问题：为了掌握这些<code>API</code>，还得懂内部工作原理，这难道不反直觉么？</p><p>如果再深究细节的话，原因是：出于降低新人上手难度的原因，官方文档并没有讲解<code>React</code>内部的架构（<code>Fiber</code>架构）。但是当我们的项目逐渐复杂，这套架构的影响就会逐渐显现。这也是很多同学只看官方文档可以入门，但难精通的原因。</p><p>以上两个问题的本质原因都在于<code>Fiber</code>架构的工作原理。</p><p>所以，我认为更好的<code>React</code>进阶方式是从了解<code>Fiber</code>架构的工作原理开始，以此为基石逐步铺开到整个<code>React</code>的方方面面。</p><h2 id="该怎么学" tabindex="-1"><a class="header-anchor" href="#该怎么学" aria-hidden="true">#</a> 该怎么学</h2>',8),v=(0,o.Uk)("根据"),x={href:"https://baike.baidu.com/item/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/50895393",target:"_blank",rel:"noopener noreferrer"},A=(0,o.Uk)("费曼学习法"),P=(0,o.Uk)("，常见的学习方式（被动学习）效果并不是最好的："),B=["src"],C=(0,o.Uk)("就我本人而言，我在写了"),E={href:"https://react.iamkasong.com/",target:"_blank",rel:"noopener noreferrer"},I=(0,o.Uk)("React技术揭秘"),w=(0,o.Uk)("（主动学习中的"),H=(0,o._)("code",null,"传授给他人",-1),W=(0,o.Uk)("）后对"),q=(0,o._)("code",null,"React",-1),F=(0,o.Uk)("的认识有了极大提高"),z=(0,o.uE)('<p>为了让大家更易学懂，本教程采用了与众不同的学习方式，主要有3点：</p><h3 id="_1-主动实践" tabindex="-1"><a class="header-anchor" href="#_1-主动实践" aria-hidden="true">#</a> 1. 主动实践</h3><p>教程配套了一个动手项目，该项目中的<code>React</code>被我魔改过源码，可以让你在控制台看到<code>React</code>源码内部的工作流程（对应主动学习中的<code>实践</code>）</p><h3 id="_2-课后习题" tabindex="-1"><a class="header-anchor" href="#_2-课后习题" aria-hidden="true">#</a> 2. 课后习题</h3><p>在习题项目中，每一课都有课后习题，供你练习这一节课学到的知识。所有习题都配备了测试用例，写完习题记得跑一遍用例看看有没有100分（对应主动学习中的<code>实践</code>）</p><h3 id="_3-课后讨论" tabindex="-1"><a class="header-anchor" href="#_3-课后讨论" aria-hidden="true">#</a> 3. 课后讨论</h3>',6),D=(0,o.Uk)("学完后有不懂的，可以加群和志同道合的小伙伴一起讨论（"),L=(0,o.Uk)("点我加群"),V=(0,o.Uk)("）（对应主动学习中的"),j=(0,o._)("code",null,"讨论",-1),y=(0,o.Uk)("）也欢迎热心的大佬们和我一起在群里给大伙儿答答疑，毕竟"),N=(0,o._)("code",null,"传授给他人",-1),O=(0,o.Uk)("是最高效的学习方式"),T=(0,o.uE)('<h2 id="我们会怎么学" tabindex="-1"><a class="header-anchor" href="#我们会怎么学" aria-hidden="true">#</a> 我们会怎么学</h2><p>前三节是基础篇，带你了解<code>React</code>内部的运行原理。有了基础，接下来我们会讨论<code>性能优化</code>、<code>Hooks底层</code>等更高阶的内容。</p><h2 id="还等什么-撸起袖子一起愉快的学习吧" tabindex="-1"><a class="header-anchor" href="#还等什么-撸起袖子一起愉快的学习吧" aria-hidden="true">#</a> 还等什么，撸起袖子一起愉快的学习吧～</h2><p>执行命令，根据提示创建课程工程目录：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>npx react53\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div>',5),Y={render:function(e,d){const c=(0,o.up)("OutboundLink"),Y=(0,o.up)("RouterLink");return(0,o.wg)(),(0,o.iD)(o.HY,null,[a,r,(0,o._)("p",null,[l,t,n,(0,o._)("a",i,[h,(0,o.Wm)(c)]),s,u,p]),k,(0,o._)("p",null,[_,(0,o._)("a",m,[b,(0,o.Wm)(c)]),g,f,U]),R,(0,o._)("p",null,[v,(0,o._)("a",x,[A,(0,o.Wm)(c)]),P]),(0,o._)("img",{src:e.$withBase("/images/feiman.png"),alt:"费曼学习法"},null,8,B),(0,o._)("blockquote",null,[(0,o._)("p",null,[C,(0,o._)("a",E,[I,(0,o.Wm)(c)]),w,H,W,q,F])]),z,(0,o._)("p",null,[D,(0,o.Wm)(Y,{to:"/extra/me.html"},{default:(0,o.w5)((()=>[L])),_:1}),V,j,y,N,O]),T],64)}}}}]);